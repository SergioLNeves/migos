# Go Unit Testing Conventions

## File Placement and Naming

- Test files live alongside the source file they test: `auth.go` -> `auth_test.go`
- Test files belong to the **same package** as the source (e.g., `package handler`, not `package handler_test`)
- This allows testing unexported functions and internal behavior

## Function Naming

Each public function gets its own top-level test function using the pattern:

```go
func TestFunctionName(t *testing.T) {
    t.Run("describes the scenario being tested", func(t *testing.T) {
        t.Parallel()
        // test body
    })
}
```

- Top-level: `TestFunctionName` matches the function under test
- Subtests via `t.Run`: describe the specific scenario (e.g., `"should return error when user not found"`)
- **Always call `t.Parallel()`** at the start of every subtest to enable concurrent execution

## Test Structure (Arrange / Act / Assert)

Every test follows three clear phases:

```go
t.Run("should return tokens on valid credentials", func(t *testing.T) {
    t.Parallel()

    // Arrange: set up mocks, inputs, expected values
    mockRepo := mock.NewMockAuthRepository(t)
    mockRepo.On("FindUserByEmail", ctx, "user@test.com").Return(user, nil)

    svc := &AuthServiceImpl{authRepository: mockRepo}

    // Act: call the function under test
    result, err := svc.Login(ctx, req)

    // Assert: verify outcomes
    assert.NoError(t, err)
    assert.NotNil(t, result)
    assert.NotEmpty(t, result.AccessToken)
})
```

## Mocks (mockery + testify)

- Mocks are generated by mockery and live in the `mock/` package
- Create mocks with `mock.NewMock<Interface>(t)` — this auto-registers cleanup and expectation assertions
- Set expectations with `.On("MethodName", args...).Return(values...)`
- Use `mock.Anything` when the exact argument value doesn't matter for the test
- **Do not** manually call `mock.AssertExpectations(t)` — the constructor already registers it via `t.Cleanup`

```go
mockService := mock.NewMockAuthService(t)
mockService.On("Login", mock.Anything, req).Return(response, nil)
```

## Assertions (testify)

Use `github.com/stretchr/testify/assert` for all assertions:

```go
assert.NoError(t, err)
assert.Error(t, err)
assert.ErrorIs(t, err, domain.ErrInvalidCredentials)
assert.Nil(t, result)
assert.NotNil(t, result)
assert.Equal(t, expected, actual)
assert.Empty(t, value)
assert.NotEmpty(t, value)
assert.Contains(t, str, "substring")
```

## Testing HTTP Handlers (Echo)

For Echo handlers, use `httptest` to create request/response pairs:

```go
e := echo.New()
req := httptest.NewRequest(http.MethodPost, "/path", body)
req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationForm)
rec := httptest.NewRecorder()
c := e.NewContext(req, rec)

err := handler.MethodUnderTest(c)

assert.NoError(t, err)
assert.Equal(t, http.StatusOK, rec.Code)
```

- For form data, use `strings.NewReader("key=value&key2=value2")` as body with `MIMEApplicationForm`
- For JSON responses, unmarshal `rec.Body.Bytes()` and assert on the fields
- To set context values (e.g., session_id from middleware), use `c.Set("key", "value")`
- To set cookies, add them to the request: `req.AddCookie(&http.Cookie{Name: "x", Value: "y"})`

## Testing Middleware (Echo)

Middleware tests should verify both the "pass-through" and "reject" paths:

```go
// Create a next handler that records if it was called
nextCalled := false
next := func(c echo.Context) error {
    nextCalled = true
    return nil
}

middlewareFunc := SessionAuth(tokenProvider, sessionRepo, authRepo)
handler := middlewareFunc(next)

err := handler(c)

assert.Equal(t, http.StatusUnauthorized, rec.Code)
assert.False(t, nextCalled)
```

## Test Coverage Goals

Test both the **happy path** and **error paths** for each function:

- Happy path: valid input, expected success
- Validation errors: invalid/missing fields
- Domain errors: e.g., `ErrInvalidCredentials`, `ErrEmailAlreadyExists`
- Infrastructure errors: repository/storage failures
- Edge cases: nil returns, empty values

## What NOT to Test

- **Repository implementations**: these are thin wrappers over storage and are covered by integration tests
- Auto-generated code (mocks, GORM models)
- Third-party library internals
